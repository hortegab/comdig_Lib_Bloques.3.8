options:
  parameters:
    author: Homero Ortega Boada
    category: comdiguis
    cmake_opt: ''
    comment: ''
    copyright: ''
    description: Guardando aqui todos los bloques de programacion embebida
    gen_cmake: 'On'
    gen_linking: dynamic
    generate_options: hb
    hier_block_src_path: '.:'
    id: b_help
    max_nouts: '0'
    output_language: python
    placement: (0,0)
    qt_qss_theme: ''
    realtime_scheduling: ''
    run: 'True'
    run_command: '{python} -u {filename}'
    run_options: prompt
    sizing_mode: fixed
    thread_safe_setters: ''
    title: b_help
    window_size: ''
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [0, 1]
    rotation: 0
    state: enabled

blocks:
- name: run_stop
  id: variable_qtgui_check_box
  parameters:
    comment: ''
    'false': 'False'
    gui_hint: 0,0,1,1
    label: Inicial/Parar
    'true': 'True'
    type: real
    value: 'True'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1064, 12]
    rotation: 0
    state: disabled
- name: samp_rate
  id: variable
  parameters:
    comment: ''
    value: '32000'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [232, 4]
    rotation: 0
    state: enabled
- name: VCO_hob
  id: epy_block
  parameters:
    _source_code: "import math\nimport numpy as np\nfrom gnuradio import gr\n\nclass\
      \ blk(gr.sync_block):\n    \"\"\"genera una senoidad cuyos parametros pueden\
      \ ser manipulados por las senales entrantes asi: la primera senal manipula la\
      \ amplitud; la segunda la frecuencia; la tercera la fase\"\"\"\n    def __init__(self):\
      \  # only default arguments here\n        gr.sync_block.__init__(\n        \
      \    self,\n            name='VCO_hob',   # will show up in GRC\n          \
      \  in_sig=[np.float32, np.float32, np.float32],\n            out_sig=[np.float32]\n\
      \        )\n        self.n_m=0 # guarda el ultimo valor de n\n\n    def work(self,\
      \ input_items, output_items):\n        A=input_items[0]\n        F=input_items[1]\n\
      \        P=input_items[2]\n        out=output_items[0]\n        L=len(A)\n \
      \       n=np.linspace(self.n_m, self.n_m+L-1,L)\n        self.n_m += L\n   \
      \     out[:]=A*np.cos(2*math.pi*F*n+P)\n        return len(out)\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: '(''VCO_hob'', ''blk'', [], [(''0'', ''float'', 1), (''1'', ''float'',
      1), (''2'', ''float'', 1)], [(''0'', ''float'', 1)], ''genera una senoidad cuyos
      parametros pueden ser manipulados por las senales entrantes asi: la primera
      senal manipula la amplitud; la segunda la frecuencia; la tercera la fase'',
      [])'
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [376, 336]
    rotation: 0
    state: disabled
- name: analog_noise_source_x_0
  id: analog_noise_source_x
  parameters:
    affinity: ''
    alias: ''
    amp: '0.1'
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    noise_type: analog.GR_GAUSSIAN
    seed: '0'
    type: complex
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [264, 460]
    rotation: 0
    state: disabled
- name: analog_sig_source_x_0
  id: analog_sig_source_x
  parameters:
    affinity: ''
    alias: ''
    amp: '1'
    comment: ''
    freq: '1000'
    maxoutbuf: '0'
    minoutbuf: '0'
    offset: '0'
    phase: '0'
    samp_rate: samp_rate
    type: complex
    waveform: analog.GR_COS_WAVE
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [264, 556]
    rotation: 0
    state: disabled
- name: coding
  id: epy_module
  parameters:
    alias: ''
    comment: ''
    source_code: "# this module will be imported in the into your flowgraph\nimport\
      \ numpy\nimport math\n#######################################################\n\
      ##        Done by Homero Ortega Boada              ##\n##        comdiguis@saber.uis.edu.co\
      \                 ##\n##     Universidad Industrial de Santander           ##\n\
      #######################################################\n#######################################################\n\
      ##       Constellation map  identification           ##\n#######################################################\
      \                  \n# Constellation points are analyzed to determine the \n\
      # the map used for ordering of the constellation points\ndef sum_modulus(a,b,modulus):\n\
      \    # realiza una suma de a y b en modulo modulus\n    return (a+b)%modulus\n\
      \ndef angle_map(constellation_points):\n    # esta funcion entrega todos los\
      \ angulos positivos entre 0 y 2pi\n    angles=numpy.angle(constellation_points)\n\
      \    return sum_modulus(angles, 2*math.pi, 2*math.pi)\n\ndef inverse_map(constellation_points):\n\
      \    M=len(constellation_points)\n    angles=angle_map(constellation_points)\n\
      \    angles=sum_modulus(angles,-angles[0], 2*math.pi) # giro a agulo cero\n\
      \    delta_angle= 2*math.pi/M     # angulo entre puntos\n    cod_inv=numpy.round(angles/delta_angle)\n\
      \    cod_inv=cod_inv.astype(numpy.int) #conversion a entero \n    return cod_inv\n\
      \ndef direct_map(constellation_points):\n    M=len(constellation_points)\n \
      \   codinv=inverse_map(constellation_points)\n    coddirect=numpy.array([0]*M)\n\
      \    for j in range(M):\n        temp=numpy.where(codinv==j)\n        coddirect[j]=temp[0][0]\n\
      \    return coddirect\n\n\"\"\" # SECCION DE PRUEBAS DEL CODIGO\nimport gnuradio.digital\
      \ as digital\nconstelacion=digital.constellation_8psk().points()\nprint(\"constelacion\
      \ = \", constelacion)\nmapdirect=direct_map(constelacion)\nprint(\"codigo directo\
      \ = \", mapdirect)\nmapinverse=inverse_map(constelacion)\nprint(\"codigo inverso\
      \ = \", mapinverse)\n\"\"\"\n\n\n\n\n\n\n"
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [176, 148]
    rotation: 0
    state: disabled
- name: e_Add
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\n\nclass blk(gr.sync_block):\
      \  \n#    \"\"\"Suma dos senales tipo char\"\"\"\n    def __init__(self,): \
      \ # only default arguments here\n        gr.sync_block.__init__(\n         \
      \   self,\n            name='e_Add_bb',   # will show up in GRC\n          \
      \  in_sig=[np.int8, np.int8],\n            out_sig=[np.int8]\n        )\n\n\
      \    def work(self, input_items, output_items):\n        output_items[0][:]\
      \ = input_items[0]+input_items[1]\n        return len(output_items[0])\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('e_Add_bb', 'blk', [], [('0', 'byte', 1), ('1', 'byte', 1)], [('0',
      'byte', 1)], '', [])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [568, 120]
    rotation: 0
    state: disabled
- name: e_M_decisor_0
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\n\nclass blk(gr.sync_block):\
      \  \n#    \"\"\"M-ary Decisor. Es un decisor para senales M_PAM. VP es el valor\
      \ pico de la senal entrante\"\"\"\n    def __init__(self,M=4, Vp=4):  # only\
      \ default arguments here\n        gr.sync_block.__init__(\n            self,\n\
      \            name='e_M_PAM_decisor',   # will show up in GRC\n            in_sig=[np.float32],\n\
      \            out_sig=[np.int8]\n        )\n\tself.M=M\n\tself.Vp=Vp\n\n    def\
      \ work(self, input_items, output_items):\n\tmpam_con_ruido=input_items[0]*(self.M+1)/(2*self.Vp)\n\
      \tmpam_sin_ruido=np.round(mpam_con_ruido)\n\n        output_items[0][:] = mpam_sin_ruido.astype(np.int8)\n\
      \        return len(output_items[0])\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ''
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [984, 356]
    rotation: 180
    state: disabled
- name: e_Multiply
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\n\nclass blk(gr.sync_block):\
      \  \n#    \"\"\"Multiplica dos senales tipo char\"\"\"\n    def __init__(self,):\
      \  # only default arguments here\n        gr.sync_block.__init__(\n        \
      \    self,\n            name='e_Multiply_bb',   # will show up in GRC\n    \
      \        in_sig=[np.int8, np.int8],\n            out_sig=[np.int8]\n       \
      \ )\n\n    def work(self, input_items, output_items):\n        output_items[0][:]\
      \ = input_items[0]*input_items[1]\n        return len(output_items[0])\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('e_Multiply_bb', 'blk', [], [('0', 'byte', 1), ('1', 'byte', 1)],
      [('0', 'byte', 1)], '', [])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [576, 216]
    rotation: 0
    state: disabled
- name: e_VCO_fase_fc_0
  id: epy_block
  parameters:
    _source_code: "\nimport numpy as np\nfrom gnuradio import gr\n\n\nclass blk(gr.sync_block):\
      \  \n    \"\"\"Done by Homero Ortega Boada. Es un VCO dos entradas: \n\tin0\
      \ para manipular la fase, in1 para manipular la \n\tmagnitud. En el fondo es\
      \ el equivalente a un generador\n\tde una senal exponencial compleja. Sobre\
      \ la configuracion:\n\tcada valor de la senal en in0 es interpretada como la\
      \ fase\n\tdeseada en radianes. cada valor de in0, es la magnitud deseada\"\"\
      \"\n\n    def __init__(self): \n        gr.sync_block.__init__(self,\n     \
      \       name='e_VCO_fase_fc',\n\t    in_sig=[np.float32, np.float32],\n    \
      \        out_sig=[np.complex64]\n        )\n    def work(self, input_items,\
      \ output_items):\n\tin0=input_items[0]\n\tin1=input_items[1]\n\tout0=output_items[0]\n\
      \tout0[:] = in1*np.exp(1.j*in0)\n\treturn len(out0)\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ''
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1136, 352]
    rotation: 0
    state: disabled
- name: e_VCO_fase_fc_0_0
  id: epy_block
  parameters:
    _source_code: "\nimport numpy as np\nfrom gnuradio import gr\n\n\nclass blk(gr.sync_block):\
      \  \n    \"\"\"Done by Homero Ortega Boada. Es un VCO dos entradas: \n\tin0\
      \ para manipular la fase, in1 para manipular la \n\tmagnitud. En el fondo es\
      \ el equivalente a un generador\n\tde una senal exponencial compleja. Sobre\
      \ la configuracion:\n\tcada valor de la senal en in0 es interpretada como la\
      \ fase\n\tdeseada en radianes. cada valor de in0, es la magnitud deseada\"\"\
      \"\n\n    def __init__(self): \n        gr.sync_block.__init__(self,\n     \
      \       name='e_VCO_fase_fc',\n\t    in_sig=[np.float32, np.float32],\n    \
      \        out_sig=[np.complex64]\n        )\n    def work(self, input_items,\
      \ output_items):\n\tin0=input_items[0]\n\tin1=input_items[1]\n\tout0=output_items[0]\n\
      \tout0[:] = in1*np.exp(1.j*in0)\n\treturn len(out0)\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ''
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [640, 344]
    rotation: 0
    state: disabled
- name: e_bipol_to_unip
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\n\nclass blk(gr.sync_block):\
      \  \n#    \"\"\"convierte de bipolar a unipolar una senal tipo char\"\"\"\n\
      \    def __init__(self,):  # only default arguments here\n        gr.sync_block.__init__(\n\
      \            self,\n            name='e_bipolar_to_unipolar_bb',   # will show\
      \ up in GRC\n            in_sig=[np.int8],\n            out_sig=[np.int8]\n\
      \        )\n\n    def work(self, input_items, output_items):\n\n        output_items[0][:]\
      \ = (input_items[0]+1)/2\n        return len(output_items[0])\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('e_bipolar_to_unipolar_bb', 'blk', [], [('0', 'byte', 1)], [('0',
      'byte', 1)], '', [])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [352, 160]
    rotation: 0
    state: disabled
- name: e_bipol_to_unip_M
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\n\nclass blk(gr.sync_block):\
      \  \n#    \"\"\"convierte de bipolar a unipolar una senal tipo char M-aria\"\
      \"\"\n    def __init__(self, M=2):  # only default arguments here\n        gr.sync_block.__init__(\n\
      \            self,\n            name='e_bipolar_to_unipolar_M_bb',   # will\
      \ show up in GRC\n            in_sig=[np.int8],\n            out_sig=[np.int8]\n\
      \        )\n\tself.M=M\n    def work(self, input_items, output_items):\n\n \
      \       output_items[0][:] = (input_items[0]+(self.M-1))/2\n        return len(output_items[0])\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ''
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [344, 252]
    rotation: 0
    state: disabled
- name: e_c_p
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\n\nclass blk(gr.sync_block):\
      \  \n    \"\"\"Autor: Homero Ortega. Permite obtener la fase de una senal compleja.\
      \ A diferencia de otros bloques de gnuradio, este entrega valores positivos\
      \ de fase entre 0 y 2pi. M es el numero de posibles fases discretas que trae\
      \ la senal\"\"\"\n    def __init__(self,M=4):  # only default arguments here\n\
      \        gr.sync_block.__init__(\n            self,\n            name='Complex\
      \ to Phase',   # will show up in GRC\n            in_sig=[np.complex64],\n \
      \           out_sig=[np.float32]\n        )\n\tself.M=M\n\tself.p2=2.*np.pi\n\
      \tself.p_margen=self.p2/(M*2.)\n\n    def work(self, input_items, output_items):\n\
      \tfases=np.angle(input_items[0]) # tiene valores negativos\n\tfases=(fases+self.p_margen\
      \ +self.p2)% self.p2-self.p_margen\n        output_items[0][:] = fases\n   \
      \     return len(output_items[0])\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ''
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [880, 172]
    rotation: 180
    state: disabled
- name: e_fft_gnu
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\n\n\nclass e_vector_fft_mag_ff(gr.sync_block):\n\
      \    \"\"\"calcula la fft en magnitud a una senal vectorial de N muestras y\
      \ emtrega N muestras del espectro. N deber ser potencia de 2\"\"\"\n\n    def\
      \ __init__(self, N=128):  \n        gr.sync_block.__init__(\n            self,\n\
      \            name='e_vector_mag_fft_ff',   \n            in_sig=[(np.float32,N)],\n\
      \            out_sig=[(np.float32,N)]\n        )\n        self.N = N\n\n   \
      \ def work(self, input_items, output_items):\n        in0 = input_items[0]\n\
      \    \tout0 = output_items[0]\n    \tout0[:]=abs(np.fft.fftshift(np.fft.fft(in0,self.N),1))\
      \ \n        return len(output_items[0])\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ''
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [776, 68]
    rotation: 0
    state: disabled
- name: e_fft_gnu_0
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\n\n\nclass e_vector_fft_ff(gr.sync_block):\n\
      \    \"\"\"calcula la fft pura a una senal vectorial de N muestras y emtrega\
      \ N muestras del espectro. N deber ser potencia de 2\"\"\"\n\n    def __init__(self,\
      \ N=128):  \n        gr.sync_block.__init__(\n            self,\n          \
      \  name='e_vector_fft_ff',   \n            in_sig=[(np.float32,N)],\n      \
      \      out_sig=[(np.float32,N)]\n        )\n        self.N = N\n\n    def work(self,\
      \ input_items, output_items):\n        in0 = input_items[0]\n    \tout0 = output_items[0]\n\
      \    \tout0[:]=np.fft.fft(in0,self.N) \n        return len(output_items[0])\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ''
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1056, 508]
    rotation: 0
    state: disabled
- name: e_mpam_ph
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\n\nclass blk(gr.sync_block):\
      \  \n#    \"\"\"Traduce M_PAM a valores de fase\"\"\"\n    def __init__(self,M=4):\
      \  # only default arguments here\n        gr.sync_block.__init__(\n        \
      \    self,\n            name='M_PAM to Phase',   # will show up in GRC\n   \
      \         in_sig=[np.int8],\n            out_sig=[np.float32]\n        )\n\t\
      self.M=M\n\tself.p2=2.*np.pi\n\n    def work(self, input_items, output_items):\n\
      \t#fases=input_items[0]*self.p2/self.M\n\n        output_items[0][:] = input_items[0]*self.p2/self.M\n\
      \        return len(output_items[0])\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ''
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [736, 236]
    rotation: 0
    state: disabled
- name: e_phase
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\n\nclass blk(gr.sync_block):\
      \  \n#    \"\"\"Traduce fases a valores de M_PAM y aplica decisor mediante redondeo\"\
      \"\"\n    def __init__(self,M=4):  # only default arguments here\n        gr.sync_block.__init__(\n\
      \            self,\n            name='phase to M_PAM',   # will show up in GRC\n\
      \            in_sig=[np.float32],\n            out_sig=[np.float32]\n      \
      \  )\n\tself.M=M\n\tself.p2=2.*np.pi\n\n    def work(self, input_items, output_items):\n\
      \tmpam_con_ruido=input_items[0]*self.M/self.p2\n\tmpam_sin_ruido=np.round(mpam_con_ruido)\n\
      \n        output_items[0][:] = mpam_sin_ruido\n        return len(output_items[0])\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ''
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [736, 172]
    rotation: 180
    state: disabled
- name: e_phase_0
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\n\nclass blk(gr.sync_block):\
      \  \n#    \"\"\"Traduce fases a valores de M_PAM y aplica decisor mediante redondeo\"\
      \"\"\n    def __init__(self,M=4):  # only default arguments here\n        gr.sync_block.__init__(\n\
      \            self,\n            name='phase to M_PAM',   # will show up in GRC\n\
      \            in_sig=[np.float32],\n            out_sig=[np.int8]\n        )\n\
      \tself.M=M\n\tself.p2=2.*np.pi\n\n    def work(self, input_items, output_items):\n\
      \tmpam_con_ruido=input_items[0]*self.M/self.p2\n\tmpam_sin_ruido=np.round(mpam_con_ruido)\n\
      \n        output_items[0][:] = mpam_sin_ruido.astype(np.int8)\n        return\
      \ len(output_items[0])\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ''
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [888, 228]
    rotation: 180
    state: disabled
- name: e_signal
  id: epy_module
  parameters:
    alias: ''
    comment: ''
    source_code: "################################################################################\n\
      ##           Funciones sigulares en Tratamiento de senales y sistemas      \
      \   ##\n################################################################################\n\
      # Lo siguiente aplica para todas las funciones aqui incluidas:\n# cada funcion\
      \ busca generar un tipo de forma de pulso rodeada de ceros\n# los resultados\
      \ se entregan en forma de un vector x\n# Estos son los parametros usados:\n\
      # ntaps: es el tamano del vector y coincide con la duracion de la senal generada\n\
      # nzero: es el numero de ceros que rodean el pulso generado. Si nzero=0 no \n\
      # habran ceros.\nimport numpy as np\n\ndef pulse_rect(ntaps,nzeros):\n# Descripcion:\
      \ esta funcion permite generar un pulso rectangular discreto\n\tn_val=ntaps-nzeros\
      \             # el numero de valores no iguales a cero\n\tx=np.zeros(ntaps)\
      \       # crea un vector de tamano ntaps lleno de ceros\n\tntaps_m= int(ntaps/2)\
      \                # el punto medio del vector\n\tntaps_i= ntaps_m-int(n_val/2)\
      \        # el punto de inicio para los unos\n\tx[ntaps_i:ntaps_i+n_val:1]=np.ones(n_val)\
      \ # llenado de los unos\n\treturn x\n\ndef pulse_ramp(ntaps,nzeros):\n# Descripcion:\
      \ esta funcion permite generar un pulso en forma de rampa discreto\n\tn_val=ntaps-nzeros\
      \            \n\tx=np.zeros(ntaps)             \n\tntaps_m= int(ntaps/2)   \
      \      \n\tntaps_i= ntaps_m-int(n_val/2) \n\tx[ntaps_i:ntaps_i+n_ones:1]=np.linspace(0,n_val-1,n_val)\
      \ \n\treturn x\n\ndef pulse_delta(ntaps):\n# Descripcion: esta funcion permite\
      \ generar la funcion impulso o funcion\n# delta de Dirac discreta\n\tx=np.zeros(ntaps)\
      \                      \n\tntaps_m= int(ntaps/2)                  \n\tx[ntaps_m]=1\
      \                           \n\treturn x\n\ndef pulse_doublet(ntaps):\n# Descripcion:\
      \ esta funcion permite generar una funcion doblete unitario discreta\n\tx=np.zeros(ntaps)\
      \                      \n\tntaps_m= int(ntaps/2)                  \n\tx[ntaps_m]=1\
      \                           \n\tx[ntaps_m+1]=-1                        \n\t\
      return x\n\ndef pulse_step(ntaps, nzeros):\n# Descripcion: esta funcion permite\
      \ generar una funcion escalon de Heaviside\n\tn_val=ntaps-nzeros           \
      \          \n\tx=np.zeros(ntaps)                      \n\tx[nzeros:ntaps:1]=np.ones(n_val)\
      \ \n\treturn x\n\ndef pulse_exp(ntaps,nzeros, C, a):\n# Descripcion: Para generar\
      \ una funcion exponencial de la forma Ca^n, \n# donde n es tiempo discreto\n\
      \tn_val=ntaps-nzeros                        \n\tx=np.zeros(ntaps)          \
      \               \n\tntaps_i = nzeros                    \n\tn=np.linspace(0,n_val-1,n_val)\
      \      \n\tx[ntaps_i:ntaps:1]=C*np.power(a,n) \n\treturn x\n\n"
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [16, 180]
    rotation: 0
    state: disabled
- name: e_unip_to_bipol
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\n\nclass blk(gr.sync_block):\
      \  \n#    \"\"\"convierte de unipolar a bipolar una senal tipo char\"\"\"\n\
      \    def __init__(self,):  # only default arguments here\n        gr.sync_block.__init__(\n\
      \            self,\n            name='e_unipolar to bipolar_bb',   # will show\
      \ up in GRC\n            in_sig=[np.int8],\n            out_sig=[np.int8]\n\
      \        )\n\n    def work(self, input_items, output_items):\n\n        output_items[0][:]\
      \ = input_items[0]*2-1\n        return len(output_items[0])\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('e_unipolar to bipolar_bb', 'blk', [], [('0', 'byte', 1)], [('0',
      'byte', 1)], '', [])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [352, 120]
    rotation: 0
    state: disabled
- name: e_unip_to_bipol_M
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\n\nclass blk(gr.sync_block):\
      \  \n#    \"\"\"convierte de unipolar a bipolar una senal tipo char M-aria.\
      \ El parametro M es para indicar si la senal es binaria (M=2), cuaternaria M=4,\
      \ etc\"\"\"\n    def __init__(self,M=2):  # only default arguments here\n  \
      \      gr.sync_block.__init__(\n            self,\n            name='e_unipolar\
      \ to bipolar_M_bb',   # will show up in GRC\n            in_sig=[np.int8],\n\
      \            out_sig=[np.int8]\n        )\n\tself.M=M\n\n    def work(self,\
      \ input_items, output_items):\n\n        output_items[0][:] = input_items[0]*2-(self.M-1)\n\
      \        return len(output_items[0])\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ''
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [344, 204]
    rotation: 0
    state: disabled
- name: epy_block_0
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\n\nclass blk(gr.sync_block):\
      \  \n    \"\"\"Coverts phase with some negative values to all positive values\"\
      \"\"\n    def __init__(self,):  # only default arguments here\n        gr.sync_block.__init__(\n\
      \            self,\n            name='positphase',   # will show up in GRC\n\
      \            in_sig=[np.float32],\n            out_sig=[np.float32]\n      \
      \  )\n\tself.p2=2*np.pi\n\n    def work(self, input_items, output_items):\n\
      \        output_items[0][:] = (input_items[0] +self.p2) % self.p2\n        return\
      \ len(output_items[0])\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ''
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [200, 376]
    rotation: 180
    state: disabled
- name: epy_block_0_0
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\n\nclass mean_meter(gr.sync_block):\n\
      \    \"\"\"Descripcion del bloque \"\"\"\n    def __init__(self):\n        gr.sync_block.__init__(self,\n\
      \            name=\"e_mean_meter_ff\",\n            in_sig=[np.float32],\n \
      \           out_sig=[np.float32])\n\n        # variables externas\n\tself.contador\
      \ = 0\n\tself.acum=0\n    def work(self, input_items, output_items):\n     \
      \   # traduccion a algo que podemos manejar mejor\n        in0 = input_items[0]\n\
      \        out0 = output_items[0]\n        # Logica principal\n\tself.contador\
      \ += len(in0)\n\tself.acum += np.sum(in0)\n\tout0[:] = self.acum/self.contador\n\
      \        return len(output_items[0])\n\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ''
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [192, 336]
    rotation: 0
    state: disabled
- name: epy_block_0_0_0
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\n\nclass decimator(gr.decim_block):\n\
      \    \"\"\"Elimins paso-1 muestras, de manera que solo quedan vigentes las muestras\
      \ separadas en paso muestras\"\"\"\n    def __init__(self, paso=2):\n      \
      \  gr.decim_block.__init__(self,\n            name=\"e_diezmad_ff\",\n     \
      \       in_sig=[np.float32],\n            out_sig=[np.float32], decim=paso)\n\
      \n        # variables externas\n\tself.paso = paso\n\t\n    def work(self, input_items,\
      \ output_items):\n        # traduccion a algo que podemos manejar mejor\n  \
      \      in0 = input_items[0]\n        out0 = output_items[0]\n        # Logica\
      \ principal\n\tout0[:] = in0[::self.paso]\n        return len(output_items[0])\n\
      \n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ''
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [824, 364]
    rotation: 0
    state: disabled
- name: epy_block_0_1
  id: epy_block
  parameters:
    _source_code: "\"\"\"\nEmbedded Python Blocks:\n\nEach time this file is saved,\
      \ GRC will instantiate the first class it finds\nto get ports and parameters\
      \ of your block. The arguments to __init__  will\nbe the parameters. All of\
      \ them are required to have default values!\n\"\"\"\n\nimport numpy as np\n\
      from gnuradio import gr\n\n\nclass blk(gr.sync_block):  \n    \"\"\"Done by\
      \ Homero Ortega Boada\"\"\"\n\n    def __init__(self, samp_rate=200000., Ac=1.):\
      \  # only default arguments here\n        \"\"\"arguments to this function show\
      \ up as parameters in GRC\"\"\"\n        gr.sync_block.__init__(\n         \
      \   self,\n            name='e_VCO_frec_fc',   # will show up in GRC\n     \
      \       in_sig=[np.float32],\n            out_sig=[np.complex64]\n        )\n\
      \        self.samp_rate = float(samp_rate)\n        self.Ac = Ac\n\tself.last_t=0.\n\
      \n    def work(self, input_items, output_items):\n\tin0=input_items[0]\n\tout0=output_items[0]\n\
      \        L=len(in0)\n\tt=np.arange(L)/self.samp_rate+self.last_t\n\ttheta=2.*np.pi*in0*t\n\
      \tout0[:] = self.Ac*np.exp(1.j*theta)\n\tself.last_t += L/self.samp_rate\n\t\
      return len(out0)\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ''
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [488, 348]
    rotation: 0
    state: disabled
- name: epy_block_0_2
  id: epy_block
  parameters:
    _source_code: "from gnuradio import gr\nimport numpy as np\n \n# Es conveninte\
      \ hacer que nombre de una clase finalice con una o dos letras especiales:\n\
      # -  nombre_ff: cuando en el bloque sus entradas y salidas son senales reales\
      \ y de tipo flotante\n# -  nombre_f: el bloque solo tiene una entrada o una\
      \ salida y es una senal real de tipo flotante\n# -  En vez de \"f\" pueden usarse:\
      \ c (senal compleja),  i (entera), b (binaria), etc.\n# -  si el es bloque es\
      \ vectorial, tambien es importante denotarlo, entonces a las letras\n# anteriores\
      \ le vamos a anteponer las letras vec\n# -  No es conveniento antepoler letras\
      \ distintivas al nombre de un bloque ya que eso\n# hace que sea mas dificl de\
      \ encontrarlo con las ayudas de un IDE com Visual Studio Code\n# -  cuando se\
      \ trate de un bloque jerarquico, los apuntadores a esos bloques los vamos\n\
      # a  senalar conmenzando el apuntador con p_, por ejemplo p_fuente=my.e_generador_fun_f()\n\
      # Un bloque puede ser de varios tipos y eso se define en la clase como:\n# .\
      \ gr.sync_block: cuando es de tipo sincrono\n# - gr.top_block: cuando es el\
      \ flujograma principal\n# - gr.decim_block: cuando hay k muestras en la entrada\
      \ por cada muestra saliente\n# - gr.interp_block: cuando hay k muestras en la\
      \ salida por cada muestra entrante\n# - gr.hier_block2: cuando el bloque es\
      \ como un flujograma\n# . gr.basic_block: otros casos\n# Nota: esta plantilla\
      \ tambien puede ser consultada en: https://github.com/hortegab/comdig_lib_code.git\n\
      \nclass e_add_cc(gr.sync_block):  \n    \"\"\"Aqui debes explicar como funciona\
      \ el bloque, los parametros usados. En este caso particular el proposito es\
      \ que esta clase sirva como ejemplo o plantilla para otras clase. La idea es\
      \ que cada vez que vayas a crear una clase para un bloque GNU Radio vuelvas\
      \ aqui ya que no es facil memorizar todos los detalles para crear un bloque\
      \ GNU Radio. En todo caso, el ejemplo consiste en un bloque para una suma escalada\
      \ de dos senales complejas. Por lo tanto hay dos senales de entrada y una de\
      \ salida. Si escala=0.5 lo que se logra es promediar las dos senales\"\"\"\n\
      \ \n    # Dentro de la funcion __init__(), deben definirse los parametros de\
      \ configuracion del bloque.\n    # A cada parametro se le da un valor por defecto\n\
      \    # ejemplo 1, solo hay un parametro de configuracion: def __init__(self,\
      \ amp=1.0)\n    # ejemplo 2, hay dos parametros: def __init__(self, amp=1.0,\
      \ samp_rate= 32000)\n    # - si el bloque es vectorial hay que incluir la variable\
      \ que marca el tamano del vector\n    # para reconocerla siempre usaremos Nvec\n\
      \    # - Nota: los bloques vectoriales se pueden implementar como embebidos,\
      \ pero hay\n    #          que tener en cuenta que el tamano del vector queda\
      \ estatico\n    #          sujeto al valor configurado internamente en este\
      \ codigo. Eso quiza sera resuelto\n    #          en la siguiente version de\
      \ gnuradio.\n    # por ejemplo def __init__(self, amp=1.0, samp_rate= 32000,\
      \ Nvec=128)\n    # a continuacion esta el caso de un solo parametro que hemos\
      \ llamado escala\n    def __init__(self, escala=0.5):\n\n        # En la siguiente\
      \ funcion debes recordar que usaras:\n        # - sync: cuando tu bloque sea\
      \ un bloque de tipo sincrono (por cada muestra entrante habra una saliente)\n\
      \        # - decim: cuando es un bloque decimador (por cada muestra saliente\
      \ hay un numero entero de muestras entrantes)\n        # - interp: cuando es\
      \ un bloque interpolador (por cada muestra entrante hay un numero entero de\
      \ muestras salientes)\n        # - basic: cuando no hay relacion entre el numero\
      \ de muestras entrantes y las salientes\n        # self: Es necesario para que\
      \ la funcion adminita el uso de self en su cuerpo para declarar\n        # variables\
      \ que pueden ser usadas por otras funciones.\n        # mas en: https://wiki.gnuradio.org/index.php/Guided_Tutorial_GNU_Radio_in_Python#3.3.1._Choosing_a_Block_Type\n\
      \        gr.sync_block.__init__(\n            self,\n \n            # Lo siguiente\
      \ es para definir el nombre que tendra nuestro bloque para los usuarios de GRC\n\
      \            name='Plantilla__detallada_para_crear_bloques_cc', \n\n       \
      \     # A continuacion se definen los tipos de senales de entrada y salida.\
      \ Veamos algunos ejemplos:\n            # - [np.complex64]: cuando se tiene\
      \ una sola senal y es compleja\n            # - [np.float32]: cuando se tiene\
      \ una sola senal y es de tipo real y flotante\n            # - [np.float32,\
      \ np.complex64]: cuando hay dos senales: una de tipo real flotante y la otra\
      \ es compleja\n            # - otros casos: int8 o byte (entero de 8 bits, que\
      \ en C++ se conoce como char)\n            # - No hemos explorado mas casos,\
      \ pero no es tan sencillo. Uno supondria que otros casos posibles son:\n   \
      \         # int16 (en C++ se conoce como short), int32, int64. Los dos primeros\
      \ funcionan, pero int64 no.\n            # - En el caso de un bloque vectorial\
      \ aqui hay que indicarlo entre (). Veamos ejemplos:\n            #   Ejemplo\
      \ 1: el bloque tiene una entraga y unsa salida y ambas son reales y vectoriales\n\
      \            #    y el tamano del vectorr es Nvec, entonces se declara asi:\n\
      \            #   * in_sig=[(np.float32,Nvec)],\n            #   * out_sig=[(np.float32,Nvec)]\n\
      \            # En el siguiente ejemplo hay dos entradas complejas y una salida\
      \ real. Todas tipo stream \n            in_sig=[np.complex64,np.complex64],\
      \ \n            out_sig=[np.complex64]\n        )\n \n        # las variables\
      \ que entran como parametros del bloque deben ser declaradas nuevamente asi:\n\
      \        self.escala=escala\n \n        # abajo se puede escribir lo que se\
      \ le antoje al programador, por ejemplo:\n        # self.coef=1.0: define la\
      \ variable global coef y le asigna el valor 1.0\n        # self significa que\
      \ es una variable global, que se puede invocar directamente desde otras funciones.\n\
      \        # En todo caso, para las cosas que se definan aqui hay que tener en\
      \ cuenta que:\n        # -  esto es parte del constructor de la clase, por lo\
      \ tanto, por cada bloque que se cree con esta clase\n        #    estas cosas\
      \ se invocaran solo una vez\n        # -  Se supone que lo que se cree aqui\
      \ es para ser usado, de manera que deberia ser usado en work()\n        # A\
      \ continuacion vamos a suponer que necesitamos usar constante  coef=1.0\n  \
      \      self.coef = 1.0\n \n    # La funcion work() siempre debe estar presente\
      \ en un bloque. Es alli donde estara la logica del bloque \n    # Es importante\
      \ que tengas en cuenta lo siguiente:\n    # - Para las senales tipo stream se\
      \ tiene que:\n    #    * input_items: es un arreglo de MxN. M es el numero de\
      \ entradas, N el numero de muestras de la senal\n    #    * in0=input_items[0]:\
      \ es un vector de longitud N, por lo tanto trae N muestras de una senal\n  \
      \  #    * in1=input_items[1]: es un vector de longitud N, por lo tanto trae\
      \ N muestras de una segunda senal\n    #    * M esta definido por la cantidad\
      \ de entradas que tiene el bloque, es decir, lo declarado arriba en in_sig\n\
      \    #    * N va cambiando con cada nueva rafaga de muestras, de modo que es\
      \ un valor desconocido\n    #        se puede calcular como N=len(input_items[0])\n\
      \    # - Si el bloque es de tipo vectorial, tenemos que el bloque input_items\
      \ es un array MxLxNvec\n    #    * M hace referencia a las senales de entrada\
      \ (representa el fondo de un cubo)\n    #    * L Al numero de paquetes recibidos\
      \ (representa la altura del cubo)\n    #    * Nvec al numero de muestras por\
      \ vector (representa el ancho del cubo)\n    #    * A cada entrada le corresponde\
      \ una matriz LxNvec, por ejemplo para la entrada cero tenmos\n    #    * in0=input_items[0]\
      \ es una matriz LxNvec, es decir una senal que trae L vectores de Nvec muestras\n\
      \    #    * Por tanto in0[0] es el primer vector de muestras de la senal, in0[1]\
      \ el segundo, etc.\n    # En el caso de output_items, aplica lo mismo dicho\
      \ para input_items, pero con las senales\n    # de salida y lo definido para\
      \ out_sig\n    # el \"self\" en la declaracion creo que es para que la funcion\
      \ acepte el uso de self internamente\n    def work(self, input_items, output_items):\n\
      \        in0 = input_items[0]\n        in1 = input_items[1]\n        out0 =\
      \ output_items[0]\n        out0[:]=(in0+in1)*self.escala/self.coef\n       \
      \ return len(out0)\n"
    affinity: ''
    alias: ''
    comment: ''
    escala: '0.5'
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('Plantilla__detallada_para_crear_bloques_cc', 'e_add_cc', [('escala',
      '0.5')], [('0', 'complex', 1), ('1', 'complex', 1)], [('0', 'complex', 1)],
      'Aqui debes explicar como funciona el bloque, los parametros usados. En este
      caso particular el proposito es que esta clase sirva como ejemplo o plantilla
      para otras clase. La idea es que cada vez que vayas a crear una clase para un
      bloque GNU Radio vuelvas aqui ya que no es facil memorizar todos los detalles
      para crear un bloque GNU Radio. En todo caso, el ejemplo consiste en un bloque
      para una suma escalada de dos senales complejas. Por lo tanto hay dos senales
      de entrada y una de salida. Si escala=0.5 lo que se logra es promediar las dos
      senales', ['escala'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [480, 480]
    rotation: 0
    state: disabled
- name: epy_block_0_3
  id: epy_block
  parameters:
    _source_code: "\"\"\"\nEmbedded Python Blocks:\n\nEach time this file is saved,\
      \ GRC will instantiate the first class it finds\nto get ports and parameters\
      \ of your block. The arguments to __init__  will\nbe the parameters. All of\
      \ them are required to have default values!\n\"\"\"\n\nimport numpy as np\n\
      from gnuradio import gr\n\n\nclass blk(gr.sync_block):  # other base classes\
      \ are basic_block, decim_block, interp_block\n    \"\"\"Suma por mudulo M\"\"\
      \"\n\n    def __init__(self, M=4, sumando=1):  # only default arguments here\n\
      \        \"\"\"arguments to this function show up as parameters in GRC\"\"\"\
      \n        gr.sync_block.__init__(\n            self,\n            name='Sum\
      \ Mod',   # will show up in GRC\n            in_sig=[np.int8],\n           \
      \ out_sig=[np.int8]\n        )\n        # if an attribute with the same name\
      \ as a parameter is found,\n        # a callback is registered (properties work,\
      \ too).\n        self.M = M\n\tself.sumando=sumando\n\n    def work(self, input_items,\
      \ output_items):\n        \"\"\"suma en modulo M\"\"\"\n        output_items[0][:]\
      \ = (input_items[0] + self.sumando%self.M)%self.M\n        return len(output_items[0])\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ''
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [26, 295]
    rotation: 0
    state: disabled
- name: epy_block_0_4
  id: epy_block
  parameters:
    _source_code: "\"\"\"\nEmbedded Python Blocks:\n\nEach time this file is saved,\
      \ GRC will instantiate the first class it finds\nto get ports and parameters\
      \ of your block. The arguments to __init__  will\nbe the parameters. All of\
      \ them are required to have default values!\n\"\"\"\n\nimport numpy as np\n\
      from gnuradio import gr\n\n\nclass blk(gr.sync_block):  # other base classes\
      \ are basic_block, decim_block, interp_block\n    \"\"\"Gray Code Converter.\
      \ Supongamos que tienes una senal dada en simbolos M_PAM, pero necesitas que\
      \ esos valores M-PAM se expresen en codigo Gray. Esta seria la solucion\"\"\"\
      \n\n    def __init__(self):  # only default arguments here\n        \"\"\"arguments\
      \ to this function show up as parameters in GRC\"\"\"\n        gr.sync_block.__init__(\n\
      \            self,\n            name='Gray Code Converter',   # will show up\
      \ in GRC\n            in_sig=[np.int8],\n            out_sig=[np.int8]\n   \
      \     )\n        # if an attribute with the same name as a parameter is found,\n\
      \        # a callback is registered (properties work, too).\n        \n\n  \
      \  def work(self, input_items, output_items):\n        \"\"\"la conversion a\
      \ gray code\"\"\"\n        output_items[0][:] = input_items[0] ^ (input_items[0]\
      \ >> 1)\n        return len(output_items[0])\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('Gray Code Converter', 'blk', [], [('0', 'byte', 1)], [('0', 'byte',
      1)], 'Gray Code Converter. Supongamos que tienes una senal dada en simbolos
      M_PAM, pero necesitas que esos valores M-PAM se expresen en codigo Gray. Esta
      seria la solucion', [])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [21, 252]
    rotation: 0
    state: disabled
- name: epy_block_0_5
  id: epy_block
  parameters:
    Sps: Sps
    _source_code: "\"\"\"\nEmbedded Python Blocks:\n\nEach time this file is saved,\
      \ GRC will instantiate the first class it finds\nto get ports and parameters\
      \ of your block. The arguments to __init__  will\nbe the parameters. All of\
      \ them are required to have default values!\n\"\"\"\n\nimport numpy as np\n\
      from gnuradio import gr\n\n\nclass blk(gr.decim_block):  # other base classes\
      \ are basic_block, decim_block, interp_block\n    \"\"\"Este bloque realiza\
      \ un diezmado asi: cada Sps muestras solo pasa una\"\"\"\n\n    def __init__(self,\
      \ Sps=8):  # only default arguments here\n        \"\"\"arguments to this function\
      \ show up as parameters in GRC\"\"\"\n        gr.decim_block.__init__(\n   \
      \         self,\n            name='e_diezmador_cc',   # will show up in GRC\n\
      \            in_sig=[np.complex64],\n            out_sig=[np.complex64], decim\
      \ = Sps\n        )\n        # if an attribute with the same name as a parameter\
      \ is found,\n        # a callback is registered (properties work, too).\n  \
      \      self.Sps = Sps\n\n    def work(self, input_items, output_items):\n  \
      \      \"\"\"example: multiply with constant\"\"\"\n        in0 = input_items[0]\n\
      \        out = output_items[0]\n        out[:] = in0[::self.Sps]\n        return\
      \ len(output_items[0])\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: '(''e_diezmador_cc'', ''blk'', [(''Sps'', ''8'')], [(''0'', ''complex'',
      1)], [(''0'', ''complex'', 1)], ''Este bloque realiza un diezmado asi: cada
      Sps muestras solo pasa una'', [''Sps''])'
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1138, 273]
    rotation: 180
    state: disabled
- name: epy_block_0_6
  id: epy_block
  parameters:
    _source_code: "\"\"\"\nEmbedded Python Blocks:\n\nEach time this file is saved,\
      \ GRC will instantiate the first class it finds\nto get ports and parameters\
      \ of your block. The arguments to __init__  will\nbe the parameters. All of\
      \ them are required to have default values!\n\"\"\"\n\nimport numpy as np\n\
      from gnuradio import gr\n\n\nclass e_bipolar_decisor_ff(gr.sync_block):  # other\
      \ base classes are basic_block, decim_block, interp_block\n    \"\"\"Hecho por\
      \ Homero Ortega Boada, UIS 2020. Entrega como salida 1 si la entrada supera\
      \ el umbral cero, pero -1 si no lo supera. Tanto la entrada como la salida es\
      \ un valor de tipo float. Se ha logrado vectorizar la operacion asi: al vector\
      \ de entrada in0 se le aplica un limitador entre 0 y 1. Osea que los valores\
      \ mayores a 1 se convierten a 1, los menores de cero a cero, con lo cual tendremos\
      \ valores entre cero y 1. Luego se aplica un redondeo hacia arriba, con lo cual\
      \ solo tendremos 0s o 1s. Luego se multiplica todo por2 y se resta 1, con lo\
      \ cual solo tendremos -1s y 1s\"\"\"\n\n    def __init__(self):  # only default\
      \ arguments here\n        \"\"\"arguments to this function show up as parameters\
      \ in GRC\"\"\"\n        gr.sync_block.__init__(\n            self,\n       \
      \     name='e_bipolar_decisor_ff',   # will show up in GRC\n            in_sig=[np.float32],\n\
      \            out_sig=[np.float32])\n        #self.Umbral=Umbral\n\n    def work(self,\
      \ input_items, output_items):\n        in0 = input_items[0]\n        out = output_items[0]\n\
      \        # Signal processing\n        out[:] = np.ceil(np.clip(in0,0,1))*2-1\n\
      \        #out[:] = [float(v>self.Umbral) for v in in0]\n        return len(output_items[0])\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: '(''e_bipolar_decisor_ff'', ''e_bipolar_decisor_ff'', [], [(''0'',
      ''float'', 1)], [(''0'', ''float'', 1)], ''Hecho por Homero Ortega Boada, UIS
      2020. Entrega como salida 1 si la entrada supera el umbral cero, pero -1 si
      no lo supera. Tanto la entrada como la salida es un valor de tipo float. Se
      ha logrado vectorizar la operacion asi: al vector de entrada in0 se le aplica
      un limitador entre 0 y 1. Osea que los valores mayores a 1 se convierten a 1,
      los menores de cero a cero, con lo cual tendremos valores entre cero y 1. Luego
      se aplica un redondeo hacia arriba, con lo cual solo tendremos 0s o 1s. Luego
      se multiplica todo por2 y se resta 1, con lo cual solo tendremos -1s y 1s'',
      [])'
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [42, 402]
    rotation: 180
    state: disabled
- name: formas
  id: epy_module
  parameters:
    alias: ''
    comment: ''
    source_code: "import math\nimport numpy as np\n# Cada funcion siguinete es una\
      \ forma de pulso para una senal digital\n# Los parametros comunmente usados\
      \ son:\n# Sps (Samples per simbol): Duracion de un simbolo en tiempo discreto\n\
      # ntaps: es el numero de muestras a generar por simbolo. Esto debido a que,\n\
      # en la practica, un simbolo puede invadir a otros simbolos (ISI), asi que\n\
      # las muestras de un simbolo se pueden expandir mas alla de Sps\n\n# Bipolar\
      \ non return to zero level signal\ndef B_NRZ_L(Sps):\n    return Sps*[1.,]\n\
      ##  Forma sinc \ndef sinc(Sps,ntaps):\n    n=np.linspace(-int(ntaps/2), int(ntaps/2-1),ntaps)\n\
      \    h=np.sinc(n/Sps)\n    return h\n# forma diente se sierra\ndef saw(Sps):\n\
      \    return np.linspace(0,Sps-1,Sps)\t\n# Bipolar non return to zero signal\n\
      def RZ(Sps):\n    h=Sps*[1.,]\n    Sps_m=int(Sps/2)\n    h[Sps_m+1:Sps:1]=np.zeros(Sps-Sps_m)\n\
      \    return h\n\n"
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [16, 220]
    rotation: 0
    state: disabled
- name: qtgui_const_sink_x_0
  id: qtgui_const_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: '"blue"'
    color10: '"red"'
    color2: '"red"'
    color3: '"red"'
    color4: '"red"'
    color5: '"red"'
    color6: '"red"'
    color7: '"red"'
    color8: '"red"'
    color9: '"red"'
    comment: ''
    grid: 'False'
    gui_hint: ''
    label1: ''
    label10: ''
    label2: ''
    label3: ''
    label4: ''
    label5: ''
    label6: ''
    label7: ''
    label8: ''
    label9: ''
    legend: 'True'
    marker1: '0'
    marker10: '0'
    marker2: '0'
    marker3: '0'
    marker4: '0'
    marker5: '0'
    marker6: '0'
    marker7: '0'
    marker8: '0'
    marker9: '0'
    name: '""'
    nconnections: '1'
    size: '1024'
    style1: '0'
    style10: '0'
    style2: '0'
    style3: '0'
    style4: '0'
    style5: '0'
    style6: '0'
    style7: '0'
    style8: '0'
    style9: '0'
    tr_chan: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: complex
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    xmax: '2'
    xmin: '-2'
    ymax: '2'
    ymin: '-2'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [816, 596]
    rotation: 0
    state: disabled
- name: qtgui_time_sink_x_0
  id: qtgui_time_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: blue
    color10: dark blue
    color2: red
    color3: green
    color4: black
    color5: cyan
    color6: magenta
    color7: yellow
    color8: dark red
    color9: dark green
    comment: ''
    ctrlpanel: 'False'
    entags: 'True'
    grid: 'False'
    gui_hint: ''
    label1: ''
    label10: ''
    label2: ''
    label3: ''
    label4: ''
    label5: ''
    label6: ''
    label7: ''
    label8: ''
    label9: ''
    legend: 'True'
    marker1: '-1'
    marker10: '-1'
    marker2: '-1'
    marker3: '-1'
    marker4: '-1'
    marker5: '-1'
    marker6: '-1'
    marker7: '-1'
    marker8: '-1'
    marker9: '-1'
    name: '""'
    nconnections: '1'
    size: '1024'
    srate: samp_rate
    stemplot: 'False'
    style1: '1'
    style10: '1'
    style2: '1'
    style3: '1'
    style4: '1'
    style5: '1'
    style6: '1'
    style7: '1'
    style8: '1'
    style9: '1'
    tr_chan: '0'
    tr_delay: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: complex
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    ylabel: Amplitude
    ymax: '1'
    ymin: '-1'
    yunit: '""'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [824, 476]
    rotation: 0
    state: disabled
- name: wform
  id: epy_module
  parameters:
    alias: ''
    comment: ''
    source_code: "import math\nimport numpy\n#######################################################\n\
      ##        Hecho por Homero Ortega Boada              ##\n##        comdiguis@saber.uis.edu.co\
      \                 ##\n##     Universidad Industrial de Santander           ##\n\
      #######################################################\n\n#######################################################\n\
      ##               Forma rectangular                   ##\n#######################################################\
      \                       \ndef rect(Sps):\n    return Sps*[1.,]\n\n#######################################################\n\
      ##               Forma de Nyquist                    ##\n#######################################################\
      \                       \ndef nyq(Sps,ntaps):\n    n=numpy.linspace(-int(ntaps/2),\
      \ int(ntaps/2-1),ntaps)\n    h=numpy.sinc(n/Sps)\n#    return h/numpy.amax(h)\n\
      \    return h\n#######################################################\n## \
      \              Forma Coseno Alzado                 ##\n#######################################################\
      \                       \ndef rcos(Sps,ntaps,beta):\n    if beta==0:\n     \
      \   h=nyq(Sps,ntaps)\n    else:\n        h=ntaps*[0,]\n        for n in range(ntaps):\n\
      \            k=n-ntaps/2. # esto es para que h[n] quede centrada en la mitad\
      \ del vector\n            if abs(k)==Sps/(2.*beta):\n                h[n]=numpy.sinc(1./(2.*beta))*math.pi/4.\n\
      \            else:\n                h[n]=numpy.sinc(k/Sps)*math.cos(beta*k*math.pi/Sps)/(1.-(2.*beta*k/Sps)**2)\
      \                \n    Amp=numpy.amax(h)\n    return h/Amp\n#######################################################\n\
      ##            Forma Raiz de Coseno Alzado            ##\n#######################################################\
      \                       \n\ndef rrcos(Sps,ntaps,beta):\n    if beta==0:\n  \
      \      h=nyq(Sps,ntaps)\n    else:\n        h=ntaps*[0,]\n        beta4=4.*beta\n\
      \        for n in range(ntaps):\n            k=n-ntaps/2. # esto es para que\
      \ h[n] quede centrada en la mitad del vector\n            if k==0:\n       \
      \         h[n]=1+beta*(4./math.pi-1.)\n            elif abs(k)==Sps/beta4:\n\
      \                ha=(1.+2./math.pi)*math.sin(math.pi/beta4)\n              \
      \  hb=(1.-2./math.pi)*math.cos(math.pi/beta4)\n                h[n]=(ha+hb)*beta/math.sqrt(2.)\n\
      \            else:\n                ks=k/Sps\n                kspi=math.pi*ks\n\
      \                Num=math.sin(kspi*(1-beta))+beta4*ks*math.cos(kspi*(1+beta))\n\
      \                Den=kspi*(1.-(beta4*ks)**2)\n                h[n]=Num/Den \
      \               \n    Amp=numpy.amax(h)\n    return h/Amp\n########################################################\n\
      ##     Bipolar non return to zero level signal        ##\n########################################################\n\
      def B_NRZ_L(Sps):\n    return Sps*[1.,]\n\n########################################################\n\
      ##  Forma sinc . Es la misma nyq() que aparece arriba ##\n########################################################\n\
      def sinc(Sps,ntaps):\n    n=np.linspace(-int(ntaps/2), int(ntaps/2-1),ntaps)\n\
      \    h=np.sinc(n/Sps)\n    return h\n########################################################\n\
      ##              forma diente se sierra                ##\n########################################################\n\
      def saw(Sps):\n    return np.linspace(0,Sps-1,Sps)\t\n########################################################\n\
      #         Bipolar non return to zero signal           ##\n########################################################\n\
      def RZ(Sps):\n    h=Sps*[1.,]\n    Sps_m=int(Sps/2)\n    h[Sps_m+1:Sps:1]=np.zeros(Sps-Sps_m)\n\
      \    return h\n"
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [16, 148]
    rotation: 0
    state: disabled

connections:
- [analog_noise_source_x_0, '0', epy_block_0_2, '0']
- [analog_sig_source_x_0, '0', epy_block_0_2, '1']
- [epy_block_0_2, '0', qtgui_const_sink_x_0, '0']
- [epy_block_0_2, '0', qtgui_time_sink_x_0, '0']

metadata:
  file_format: 1
